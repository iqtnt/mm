import tkinter as tk
from tkinter import ttk, messagebox
import webbrowser
from urllib.parse import urlparse, parse_qs
import re
import requests
from PIL import Image, ImageTk
from io import BytesIO
from datetime import datetime
import os

FILENAME = "youtube_links.txt"

# ---------------- helpers ----------------
def sanitize_link(link: str) -> str:
    link = link.strip()
    if not link:
        return ""
    if link.startswith("www."):
        link = "https://" + link
    if link.startswith("youtu.be/") or link.startswith("youtube.com/") and not link.startswith("http"):
        link = "https://" + link
    if not link.startswith("http"):
        link = "https://" + link
    return link

def get_video_id(link):
    parsed = urlparse(link)
    if "youtu.be" in parsed.netloc:
        return parsed.path.lstrip("/")
    if "youtube" in parsed.netloc:
        qs = parse_qs(parsed.query)
        if "v" in qs:
            return qs["v"][0]
    if re.match(r"^[A-Za-z0-9_-]{11}$", link):
        return link
    return None

def extract_short_title_from_url(url: str) -> str:
    vid = get_video_id(url)
    return f"Video {vid}" if vid else "Untitled"

def get_thumbnail(video_id):
    thumbs = ["maxresdefault.jpg","sddefault.jpg","hqdefault.jpg","mqdefault.jpg","default.jpg"]
    for t in thumbs:
        url = f"https://i.ytimg.com/vi/{video_id}/{t}"
        try:
            r = requests.get(url, timeout=5)
            if r.status_code == 200:
                img = Image.open(BytesIO(r.content)).resize((120, 90))
                return ImageTk.PhotoImage(img)
        except:
            continue
    return None

def format_status(watched):
    return "ğŸ† Watched" if watched else "âŒ Not watched"

# ---------------- storage ----------------
def load_links():
    if os.path.exists(FILENAME):
        with open(FILENAME, "r", encoding="utf-8") as f:
            lines = [line.strip() for line in f.readlines() if line.strip()]
            data = []
            for line in lines:
                parts = line.split("|")
                if len(parts) == 4:
                    title, link, watched, date = parts
                    data.append([title, link, watched=="1", date, None])
                elif len(parts)==2:
                    title, link = parts
                    date = datetime.now().strftime("%Y-%m-%d %H:%M")
                    data.append([title, link, False, date, None])
                else:
                    link = line.strip()
                    title = extract_short_title_from_url(link)
                    date = datetime.now().strftime("%Y-%m-%d %H:%M")
                    data.append([title, link, False, date, None])
            return data
    return []

def save_links():
    with open(FILENAME, "w", encoding="utf-8") as f:
        for title, link, watched, date, _ in links:  # ØªØ¬Ø§Ù‡Ù„ Ø§Ù„ØµÙˆØ±Ø© Ø¹Ù†Ø¯ Ø§Ù„Ø­ÙØ¸
            f.write(f"{title}|{link}|{1 if watched else 0}|{date}\n")

# ---------------- actions ----------------
def add_link():
    title = title_entry.get().strip()
    link = link_entry.get().strip()
    link = sanitize_link(link)
    if not link:
        messagebox.showwarning("Warning","Please enter a link")
        return
    if not title:
        title = extract_short_title_from_url(link)
    date = datetime.now().strftime("%Y-%m-%d %H:%M")
    vid = get_video_id(link)
    thumb = get_thumbnail(vid)
    links.append([title, link, False, date, thumb])
    refresh_tree()
    save_links()
    title_entry.delete(0, tk.END)
    link_entry.delete(0, tk.END)

def paste_link(event=None):
    try:
        clip = root.clipboard_get().strip()
        if clip:
            link_entry.delete(0, tk.END)
            link_entry.insert(0, clip)
            if not title_entry.get().strip():
                title_entry.delete(0, tk.END)
                title_entry.insert(0, extract_short_title_from_url(clip))
    except tk.TclError:
        pass
    return "break"

def delete_selected():
    indices = tree.selection()
    if not indices:
        messagebox.showwarning("Warning","Select at least one link to delete")
        return
    for i in reversed(indices):
        idx = int(tree.item(i, "tags")[0])
        links.pop(idx)
    save_links()
    refresh_tree()

def mark_watched():
    indices = tree.selection()
    if not indices:
        messagebox.showwarning("Warning","Select at least one link to mark watched")
        return
    for i in indices:
        idx = int(tree.item(i,"tags")[0])
        links[idx][2]=True
    save_links()
    refresh_tree()

def open_selected():
    indices = tree.selection()
    if not indices:
        messagebox.showwarning("Warning","Select at least one link to watch")
        return
    for i in indices:
        idx = int(tree.item(i,"tags")[0])
        webbrowser.open(links[idx][1])

def search_links(*args):
    query = search_var.get().lower()
    refresh_tree(query)

def refresh_tree(query=""):
    tree.delete(*tree.get_children())
    filtered = []
    for idx, item in enumerate(links):
        if query in item[0].lower():
            filtered.append((idx, item))
    for idx, (title, link, watched, date, thumb) in filtered:
        tree.insert("", tk.END, values=(title, link, date, format_status(watched)), image=thumb, tags=(str(idx),))
        if thumb:
            images.append(thumb)  # Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØ±Ø© ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø©

# ---------------- GUI ----------------
root = tk.Tk()
root.title("YouTube Watchlist")
root.geometry("900x600")
root.resizable(False, False)

bg_color="#121212"
fg_color="#ffffff"
entry_bg="#1e1e1e"
btn_green="#4CAF50"
btn_blue="#2196F3"
btn_red="#f44336"
btn_gray="#6a6a6a"
btn_gold="#FFD700"
root.configure(bg=bg_color)

images=[]

# ---------------- Ø§Ù„Ø­Ù‚ÙˆÙ„ ----------------
title_frame=tk.Frame(root,bg=bg_color)
title_frame.pack(pady=5)
tk.Label(title_frame,text="Title",bg=bg_color,fg=fg_color).pack()
title_entry=tk.Entry(title_frame,width=50,bg=entry_bg,fg=fg_color,insertbackground=fg_color,justify="center")
title_entry.pack()

link_frame=tk.Frame(root,bg=bg_color)
link_frame.pack(pady=5)
tk.Label(link_frame,text="YouTube Link",bg=bg_color,fg=fg_color).pack()
link_entry=tk.Entry(link_frame,width=50,bg=entry_bg,fg=fg_color,insertbackground=fg_color,justify="center")
link_entry.pack()
link_entry.bind("<Control-v>", paste_link)
link_entry.bind("<Control-V>", paste_link)
title_entry.bind("<Control-v>", paste_link)
title_entry.bind("<Control-V>", paste_link)

# ---------------- Ø§Ù„Ø£Ø²Ø±Ø§Ø± ----------------
btn_frame=tk.Frame(root,bg=bg_color)
btn_frame.pack(pady=10)
tk.Button(btn_frame,text="Add",bg=btn_green,fg="white",width=12,command=add_link).pack(side=tk.LEFT,padx=5)
tk.Button(btn_frame,text="Paste",bg=btn_gray,fg="white",width=12,command=paste_link).pack(side=tk.LEFT,padx=5)
tk.Button(btn_frame,text="Watch",bg=btn_blue,fg="white",width=12,command=open_selected).pack(side=tk.LEFT,padx=5)
tk.Button(btn_frame,text="Delete",bg=btn_red,fg="white",width=12,command=delete_selected).pack(side=tk.LEFT,padx=5)
tk.Button(btn_frame,text="Mark as Watched",bg=btn_gold,fg="black",width=15,command=mark_watched).pack(side=tk.LEFT,padx=5)

# ---------------- Ø§Ù„Ø¨Ø­Ø« ----------------
search_frame=tk.Frame(root,bg=bg_color)
search_frame.pack(pady=5)
search_var=tk.StringVar()
search_var.trace("w", search_links)
tk.Label(search_frame,text="Search by Title",bg=bg_color,fg=fg_color).pack()
search_entry=tk.Entry(search_frame,textvariable=search_var,width=50,bg=entry_bg,fg=fg_color,insertbackground=fg_color,justify="center")
search_entry.pack()

# ---------------- Treeview ----------------
columns=("Title","Link","Date","Status")
tree=ttk.Treeview(root,columns=columns,show="headings",height=18)
for col in columns:
    tree.heading(col,text=col)
tree.column("Title",width=250)
tree.column("Link",width=300)
tree.column("Date",width=130)
tree.column("Status",width=100)
tree.pack(fill=tk.BOTH,expand=True,pady=10)

# ---------------- ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ----------------
links=load_links()
filtered_links=links[:]
refresh_tree()

root.mainloop()
